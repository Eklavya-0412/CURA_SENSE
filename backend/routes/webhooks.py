"""
Webhook Routes - Automatic Error Ingestion
Receives real-time error signals from merchant websites and auto-generates tickets.

Endpoints:
- POST /webhook/error - Receives error events from merchant JS SDK
- POST /webhook/checkout-failure - Receives checkout failure signals
- POST /webhook/api-failure - Receives API failure signals
- GET /webhook/sdk.js - Returns the JavaScript SDK for merchants to embed
"""

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from datetime import datetime
import uuid

from models.types import SupportTicket, ErrorLog, MigrationStage
from services.support_agent import support_agent

router = APIRouter(prefix="/webhook", tags=["webhooks"])


# ============ Webhook Payload Models ============

class ErrorEvent(BaseModel):
    """Error event from merchant website/SDK"""
    merchant_id: str
    error_type: str  # 'javascript', 'api', 'checkout', 'webhook', 'payment'
    error_message: str
    error_code: Optional[str] = None
    stack_trace: Optional[str] = None
    url: Optional[str] = None
    user_agent: Optional[str] = None
    timestamp: Optional[str] = None
    context: Optional[Dict[str, Any]] = None


class CheckoutFailure(BaseModel):
    """Checkout failure event"""
    merchant_id: str
    order_id: Optional[str] = None
    error_message: str
    error_code: Optional[str] = None
    payment_method: Optional[str] = None
    cart_value: Optional[float] = None
    currency: Optional[str] = "USD"
    customer_id: Optional[str] = None
    timestamp: Optional[str] = None


class APIFailure(BaseModel):
    """API failure event"""
    merchant_id: str
    endpoint: str
    method: str  # GET, POST, PUT, DELETE
    status_code: int
    error_message: str
    request_id: Optional[str] = None
    latency_ms: Optional[int] = None
    timestamp: Optional[str] = None


class WebhookFailure(BaseModel):
    """Webhook delivery failure"""
    merchant_id: str
    webhook_url: str
    event_type: str
    error_message: str
    status_code: Optional[int] = None
    retry_count: Optional[int] = 0
    timestamp: Optional[str] = None


# ============ Error â†’ Ticket Conversion ============

def create_ticket_from_error(error: ErrorEvent) -> SupportTicket:
    """Convert an error event into a support ticket"""
    
    # Map error types to categories
    category_map = {
        "javascript": "frontend",
        "api": "api",
        "checkout": "checkout",
        "webhook": "webhooks",
        "payment": "payments"
    }
    
    # Determine priority based on error type
    priority_map = {
        "checkout": "critical",
        "payment": "critical",
        "webhook": "high",
        "api": "high",
        "javascript": "medium"
    }
    
    return SupportTicket(
        id=f"AUTO-{uuid.uuid4().hex[:8].upper()}",
        merchant_id=error.merchant_id,
        subject=f"[Auto-Detected] {error.error_type.title()} Error: {error.error_message[:50]}",
        description=f"""
**Automatically detected error from merchant site**

**Error Type:** {error.error_type}
**Error Message:** {error.error_message}
**Error Code:** {error.error_code or 'N/A'}
**URL:** {error.url or 'N/A'}

**Stack Trace:**
```
{error.stack_trace or 'N/A'}
```

**Context:** {error.context or {}}

*This ticket was auto-generated by MigraGuard error monitoring.*
        """.strip(),
        migration_stage=MigrationStage.UNKNOWN,
        priority=priority_map.get(error.error_type, "medium"),
        timestamp=error.timestamp or datetime.now().isoformat(),
        metadata={
            "category": category_map.get(error.error_type, "general"),
            "product": "auto-detected",
            "source": "webhook",
            "auto_generated": True,
            "user_agent": error.user_agent
        }
    )


def create_ticket_from_checkout_failure(failure: CheckoutFailure) -> SupportTicket:
    """Convert checkout failure into a critical support ticket"""
    return SupportTicket(
        id=f"CHK-{uuid.uuid4().hex[:8].upper()}",
        merchant_id=failure.merchant_id,
        subject=f"[CRITICAL] Checkout Failure: {failure.error_message[:50]}",
        description=f"""
**CRITICAL: Checkout Failure Detected**

**Error Code:** {failure.error_code or 'N/A'}
**Error Message:** {failure.error_message}
**Order ID:** {failure.order_id or 'N/A'}
**Payment Method:** {failure.payment_method or 'N/A'}
**Cart Value:** {failure.currency} {failure.cart_value or 'Unknown'}

This is a revenue-impacting issue that requires immediate attention.

*Auto-generated by MigraGuard checkout monitoring.*
        """.strip(),
        migration_stage=MigrationStage.POST_MIGRATION,
        priority="critical",
        timestamp=failure.timestamp or datetime.now().isoformat(),
        metadata={
            "category": "checkout",
            "product": "checkout-api",
            "source": "webhook",
            "auto_generated": True,
            "revenue_impact": failure.cart_value
        }
    )


def create_ticket_from_api_failure(failure: APIFailure) -> SupportTicket:
    """Convert API failure into a support ticket"""
    priority = "critical" if failure.status_code >= 500 else "high"
    
    return SupportTicket(
        id=f"API-{uuid.uuid4().hex[:8].upper()}",
        merchant_id=failure.merchant_id,
        subject=f"[Auto-Detected] API Error {failure.status_code} on {failure.endpoint}",
        description=f"""
**API Failure Detected**

**Endpoint:** {failure.method} {failure.endpoint}
**Status Code:** {failure.status_code}
**Error Message:** {failure.error_message}
**Request ID:** {failure.request_id or 'N/A'}
**Latency:** {failure.latency_ms or 'N/A'}ms

*Auto-generated by MigraGuard API monitoring.*
        """.strip(),
        migration_stage=MigrationStage.POST_MIGRATION,
        priority=priority,
        timestamp=failure.timestamp or datetime.now().isoformat(),
        metadata={
            "category": "api",
            "product": "api-gateway",
            "source": "webhook",
            "auto_generated": True,
            "status_code": failure.status_code
        }
    )


# ============ Webhook Endpoints ============

@router.post("/error")
async def receive_error_event(error: ErrorEvent, request: Request):
    """
    Receives error events from merchant websites.
    Auto-generates a ticket and triggers AI analysis.
    
    Merchants embed the MigraGuard SDK which calls this endpoint on errors.
    """
    # Create ticket from error
    ticket = create_ticket_from_error(error)
    
    # Trigger async analysis
    session_id = await support_agent.analyze_async(
        client_message=ticket.description,
        merchant_id=error.merchant_id
    )
    
    # Also store the structured ticket for history
    support_agent._sessions[session_id]["original_ticket"] = ticket.model_dump()
    support_agent._sessions[session_id]["auto_generated"] = True
    
    return {
        "status": "received",
        "ticket_id": ticket.id,
        "session_id": session_id,
        "message": "Error captured and analysis started"
    }


@router.post("/checkout-failure")
async def receive_checkout_failure(failure: CheckoutFailure):
    """
    Receives checkout failure signals - treated as CRITICAL priority.
    These are revenue-impacting and get fast-tracked.
    """
    ticket = create_ticket_from_checkout_failure(failure)
    
    session_id = await support_agent.analyze_async(
        client_message=ticket.description,
        merchant_id=failure.merchant_id
    )
    
    support_agent._sessions[session_id]["original_ticket"] = ticket.model_dump()
    support_agent._sessions[session_id]["auto_generated"] = True
    support_agent._sessions[session_id]["critical"] = True
    
    return {
        "status": "received",
        "ticket_id": ticket.id,
        "session_id": session_id,
        "priority": "critical",
        "message": "Checkout failure captured - CRITICAL priority analysis started"
    }


@router.post("/api-failure")
async def receive_api_failure(failure: APIFailure):
    """
    Receives API failure signals from merchant integrations.
    """
    ticket = create_ticket_from_api_failure(failure)
    
    session_id = await support_agent.analyze_async(
        client_message=ticket.description,
        merchant_id=failure.merchant_id
    )
    
    support_agent._sessions[session_id]["original_ticket"] = ticket.model_dump()
    support_agent._sessions[session_id]["auto_generated"] = True
    
    return {
        "status": "received",
        "ticket_id": ticket.id,
        "session_id": session_id,
        "message": "API failure captured and analysis started"
    }


@router.post("/webhook-failure")
async def receive_webhook_failure(failure: WebhookFailure):
    """
    Receives webhook delivery failure signals.
    """
    ticket = SupportTicket(
        id=f"WHK-{uuid.uuid4().hex[:8].upper()}",
        merchant_id=failure.merchant_id,
        subject=f"[Auto-Detected] Webhook Delivery Failed: {failure.event_type}",
        description=f"""
**Webhook Delivery Failure**

**Webhook URL:** {failure.webhook_url}
**Event Type:** {failure.event_type}
**Error:** {failure.error_message}
**Status Code:** {failure.status_code or 'N/A'}
**Retry Count:** {failure.retry_count}

*Auto-generated by MigraGuard webhook monitoring.*
        """.strip(),
        migration_stage=MigrationStage.POST_MIGRATION,
        priority="high",
        timestamp=failure.timestamp or datetime.now().isoformat(),
        metadata={
            "category": "webhooks",
            "product": "webhook-delivery",
            "source": "webhook",
            "auto_generated": True
        }
    )
    
    session_id = await support_agent.analyze_async(
        client_message=ticket.description,
        merchant_id=failure.merchant_id
    )
    
    support_agent._sessions[session_id]["original_ticket"] = ticket.model_dump()
    support_agent._sessions[session_id]["auto_generated"] = True
    
    return {
        "status": "received",
        "ticket_id": ticket.id,
        "session_id": session_id,
        "message": "Webhook failure captured and analysis started"
    }


# ============ JavaScript SDK ============

@router.get("/sdk.js")
async def get_sdk_script():
    """
    Returns the JavaScript SDK for merchants to embed in their websites.
    This SDK auto-captures errors and sends them to MigraGuard.
    """
    sdk_code = """
// MigraGuard Error Monitoring SDK
(function(window) {
    'use strict';
    
    const MigraGuard = {
        merchantId: null,
        apiEndpoint: null,
        
        init: function(config) {
            this.merchantId = config.merchantId;
            this.apiEndpoint = config.apiEndpoint || 'http://localhost:8000';
            
            // Auto-capture JavaScript errors
            window.onerror = (msg, url, line, col, error) => {
                this.captureError({
                    error_type: 'javascript',
                    error_message: msg,
                    error_code: 'JS_ERROR',
                    url: url,
                    stack_trace: error ? error.stack : null,
                    context: { line, col }
                });
                return false;
            };
            
            // Capture unhandled promise rejections
            window.addEventListener('unhandledrejection', (event) => {
                this.captureError({
                    error_type: 'javascript',
                    error_message: event.reason?.message || String(event.reason),
                    error_code: 'UNHANDLED_PROMISE',
                    stack_trace: event.reason?.stack || null
                });
            });
            
            console.log('[MigraGuard] Error monitoring initialized for merchant:', this.merchantId);
        },
        
        captureError: function(errorData) {
            const payload = {
                merchant_id: this.merchantId,
                ...errorData,
                user_agent: navigator.userAgent,
                url: errorData.url || window.location.href,
                timestamp: new Date().toISOString()
            };
            
            fetch(this.apiEndpoint + '/webhook/error', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).catch(err => console.error('[MigraGuard] Failed to report error:', err));
        },
        
        captureCheckoutFailure: function(data) {
            fetch(this.apiEndpoint + '/webhook/checkout-failure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    merchant_id: this.merchantId,
                    ...data,
                    timestamp: new Date().toISOString()
                })
            }).catch(err => console.error('[MigraGuard] Failed to report checkout failure:', err));
        },
        
        captureAPIFailure: function(data) {
            fetch(this.apiEndpoint + '/webhook/api-failure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    merchant_id: this.merchantId,
                    ...data,
                    timestamp: new Date().toISOString()
                })
            }).catch(err => console.error('[MigraGuard] Failed to report API failure:', err));
        }
    };
    
    window.MigraGuard = MigraGuard;
})(window);

// Usage:
// MigraGuard.init({ merchantId: 'MCH-1001', apiEndpoint: 'http://localhost:8000' });
// MigraGuard.captureCheckoutFailure({ error_message: 'Payment failed', order_id: '123' });
"""
    
    from fastapi.responses import Response
    return Response(content=sdk_code, media_type="application/javascript")


# ============ Auto-Fix Capability ============

@router.post("/auto-fix/{session_id}")
async def trigger_auto_fix(session_id: str):
    """
    Attempts to auto-fix a low-risk issue without human approval.
    Only works for issues that meet the auto-fix criteria:
    - Low risk level
    - High confidence diagnosis
    - Reversible action
    - Known fix pattern
    """
    session = support_agent._sessions.get(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    risk_assessment = session.get("risk_assessment")
    diagnosis = session.get("diagnosis")
    
    # Check if auto-fix is safe
    can_auto_fix = (
        risk_assessment and 
        hasattr(risk_assessment, 'risk_level') and
        risk_assessment.risk_level.value == "low" and
        diagnosis and
        hasattr(diagnosis, 'confidence') and
        diagnosis.confidence >= 0.85 and
        risk_assessment.reversibility == True
    )
    
    if not can_auto_fix:
        return {
            "status": "requires_approval",
            "message": "This issue does not meet auto-fix criteria. Human approval required.",
            "reason": "Risk too high or confidence too low"
        }
    
    # Execute auto-fix (in a real system, this would call actual fix functions)
    proposed_action = session.get("proposed_action")
    
    return {
        "status": "auto_fixed",
        "message": "Issue has been automatically resolved",
        "action_taken": proposed_action.draft_content if proposed_action else "Applied standard fix",
        "session_id": session_id
    }
